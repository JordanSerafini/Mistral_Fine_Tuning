{"messages":[{"role":"user","content":"Montre-moi tous les projets en cours"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name FROM projects p JOIN clients c ON p.client_id = c.id WHERE p.status = 'en_cours' ORDER BY p.start_date DESC;"}]}
{"messages":[{"role":"user","content":"Crée un nouveau projet pour le client Dupont"},{"role":"assistant","content":"INSERT INTO projects (client_id, name, description, status, start_date) VALUES ((SELECT id FROM clients WHERE lastname = 'Dupont' LIMIT 1), 'Nouveau projet Dupont', 'Description du projet', 'en_cours', CURRENT_DATE);"}]}
{"messages":[{"role":"user","content":"Recherche tous les projets terminés depuis 2023"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name FROM projects p JOIN clients c ON p.client_id = c.id WHERE p.status = 'termine' AND p.end_date >= '2023-01-01' ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Met à jour le statut du projet 123 à terminé"},{"role":"assistant","content":"UPDATE projects SET status = 'termine', end_date = CURRENT_DATE, updated_at = CURRENT_TIMESTAMP WHERE id = 123;"}]}
{"messages":[{"role":"user","content":"Trouve tous les projets dans la ville de Paris"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name FROM projects p JOIN clients c ON p.client_id = c.id WHERE p.city ILIKE 'Paris' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec un budget supérieur à 50000€"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name, pb.total_budget FROM projects p JOIN clients c ON p.client_id = c.id JOIN project_budgets pb ON p.id = pb.project_id WHERE pb.total_budget > 50000 ORDER BY pb.total_budget DESC;"}]}
{"messages":[{"role":"user","content":"Cherche les projets qui n'ont pas encore démarré"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name FROM projects p JOIN clients c ON p.client_id = c.id WHERE p.start_date > CURRENT_DATE OR p.start_date IS NULL ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leurs étapes en cours"},{"role":"assistant","content":"SELECT p.*, s.name as stage_name, s.status as stage_status, c.firstname || ' ' || c.lastname as client_name FROM projects p JOIN stages s ON p.id = s.project_id JOIN clients c ON p.client_id = c.id WHERE s.status = 'en_cours' ORDER BY p.start_date, s.order_index;"}]}
{"messages":[{"role":"user","content":"Liste les projets qui nécessitent des matériaux spécifiques"},{"role":"assistant","content":"SELECT p.*, m.name as material_name, pm.quantity FROM projects p JOIN project_materials pm ON p.id = pm.project_id JOIN materials m ON pm.material_id = m.id WHERE p.status = 'en_cours' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets qui dépassent leur budget initial"},{"role":"assistant","content":"SELECT p.*, pb.total_budget, SUM(e.amount) as total_expenses FROM projects p JOIN project_budgets pb ON p.id = pb.project_id JOIN expenses e ON p.id = e.project_id GROUP BY p.id, pb.total_budget HAVING SUM(e.amount) > pb.total_budget;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec le plus d'heures travaillées"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name, SUM(te.hours) as total_hours FROM projects p JOIN timesheet_entries te ON p.id = te.project_id JOIN clients c ON p.client_id = c.id GROUP BY p.id, c.firstname, c.lastname ORDER BY total_hours DESC LIMIT 10;"}]}
{"messages":[{"role":"user","content":"Recherche les projets qui ont des factures impayées"},{"role":"assistant","content":"SELECT p.*, i.reference as invoice_ref, i.total_ttc, i.due_date FROM projects p JOIN invoices i ON p.id = i.project_id WHERE i.status = 'en_retard' OR (i.status = 'envoyée' AND i.due_date < CURRENT_DATE) ORDER BY i.due_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets par ordre de rentabilité"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name, (SELECT SUM(total_ttc) FROM invoices WHERE project_id = p.id) - (SELECT COALESCE(SUM(amount), 0) FROM expenses WHERE project_id = p.id) as profit FROM projects p JOIN clients c ON p.client_id = c.id WHERE p.status = 'termine' ORDER BY profit DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets qui requièrent une intervention urgente"},{"role":"assistant","content":"SELECT p.*, ce.title as event_title, ce.start_date FROM projects p JOIN calendar_events ce ON p.id = ce.project_id WHERE ce.event_type = 'intervention_urgente' AND ce.start_date >= CURRENT_DATE ORDER BY ce.start_date;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec le plus de devis acceptés"},{"role":"assistant","content":"SELECT p.*, COUNT(q.id) as accepted_quotes, SUM(q.total) as total_amount FROM projects p JOIN quotations q ON p.id = q.project_id WHERE q.status = 'accepté' GROUP BY p.id ORDER BY accepted_quotes DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets par équipe assignée"},{"role":"assistant","content":"SELECT p.*, array_agg(s.firstname || ' ' || s.lastname) as team_members FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id WHERE p.status = 'en_cours' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leurs équipements réservés"},{"role":"assistant","content":"SELECT p.*, e.name as equipment_name, er.start_date, er.end_date FROM projects p JOIN equipment_reservations er ON p.id = er.project_id JOIN equipment e ON er.equipment_id = e.id WHERE er.start_date <= CURRENT_DATE AND er.end_date >= CURRENT_DATE ORDER BY er.start_date;"}]}
{"messages":[{"role":"user","content":"Trouve tous les projets avec leurs devis associés"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name, array_agg(jsonb_build_object('devis_ref', q.reference, 'montant', q.total, 'statut', q.status)) as devis FROM projects p JOIN clients c ON p.client_id = c.id LEFT JOIN quotations q ON p.id = q.project_id GROUP BY p.id, c.firstname, c.lastname ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leurs factures et paiements"},{"role":"assistant","content":"SELECT p.*, i.reference as facture_ref, i.total_ttc, array_agg(jsonb_build_object('date_paiement', pay.payment_date, 'montant', pay.amount, 'methode', pay.payment_method)) as paiements FROM projects p JOIN invoices i ON p.id = i.project_id LEFT JOIN payments pay ON i.id = pay.invoice_id GROUP BY p.id, i.reference, i.total_ttc ORDER BY p.start_date DESC;"}]}
{"messages":[{"role":"user","content":"Recherche les projets avec leur planning complet"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name, array_agg(DISTINCT jsonb_build_object('evenement', ce.title, 'type', ce.event_type, 'date_debut', ce.start_date, 'date_fin', ce.end_date)) as planning FROM projects p JOIN clients c ON p.client_id = c.id LEFT JOIN calendar_events ce ON p.id = ce.project_id WHERE p.status = 'en_cours' GROUP BY p.id, c.firstname, c.lastname ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur équipe et les heures travaillées"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('staff', s.firstname || ' ' || s.lastname, 'role', ps.role, 'heures_total', COALESCE((SELECT SUM(hours) FROM timesheet_entries te WHERE te.staff_id = s.id AND te.project_id = p.id), 0))) as equipe FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leurs matériaux et fournisseurs"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('materiel', m.name, 'quantite', pm.quantity, 'fournisseur', sup.name)) as materiaux FROM projects p JOIN project_materials pm ON p.id = pm.project_id JOIN materials m ON pm.material_id = m.id LEFT JOIN suppliers sup ON m.id = sup.id GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leurs devis et factures en attente"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('devis_ref', q.reference, 'montant_devis', q.total)) as devis_en_attente, array_agg(DISTINCT jsonb_build_object('facture_ref', i.reference, 'montant_du', i.total_ttc)) as factures_impayees FROM projects p LEFT JOIN quotations q ON p.id = q.project_id AND q.status = 'en_attente' LEFT JOIN invoices i ON p.id = i.project_id AND i.status IN ('envoyée', 'en_retard') GROUP BY p.id;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leurs étapes et responsables"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('etape', s.name, 'status', s.status, 'responsable', st.firstname || ' ' || st.lastname, 'debut', s.start_date, 'fin', s.end_date)) as etapes FROM projects p LEFT JOIN stages s ON p.id = s.project_id LEFT JOIN staff st ON s.staff_id = st.id GROUP BY p.id ORDER BY p.start_date DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leurs dépenses par catégorie"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('categorie', ec.name, 'total_depenses', SUM(e.amount))) as depenses_par_categorie FROM projects p LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN expense_categories ec ON e.category_id = ec.id GROUP BY p.id, ec.name ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Recherche les projets avec leurs équipements réservés et maintenance"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('equipement', e.name, 'periode', er.start_date || ' à ' || er.end_date, 'maintenance', mr.maintenance_date)) as equipements FROM projects p JOIN equipment_reservations er ON p.id = er.project_id JOIN equipment e ON er.equipment_id = e.id LEFT JOIN maintenance_records mr ON e.id = mr.equipment_id GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur historique d'activités"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('action', al.action, 'details', al.details, 'date', al.created_at, 'utilisateur', u.firstname || ' ' || u.lastname)) as activites FROM projects p LEFT JOIN activity_logs al ON p.id = (al.details->>'project_id')::integer LEFT JOIN users u ON al.user_id = u.id GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve tous les projets avec leurs devis en attente et le statut du projet"},{"role":"assistant","content":"SELECT p.*, q.reference as devis_ref, q.total, q.status as devis_status FROM projects p LEFT JOIN quotations q ON p.id = q.project_id WHERE p.status::project_status = 'en_cours' AND q.status::quotation_status = 'en_attente' ORDER BY q.created_date DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leurs événements de type réunion de chantier à venir"},{"role":"assistant","content":"SELECT p.*, ce.title, ce.start_date, ce.end_date FROM projects p JOIN calendar_events ce ON p.id = ce.project_id WHERE ce.event_type::event_type = 'reunion_chantier' AND ce.start_date > CURRENT_TIMESTAMP AND p.status::project_status IN ('prospect', 'en_cours') ORDER BY ce.start_date;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leurs activités de création ou modification récentes"},{"role":"assistant","content":"SELECT p.*, al.action::activity_type, al.created_at, al.details FROM projects p JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id WHERE al.action::activity_type IN ('create', 'update', 'modification') AND al.created_at > CURRENT_DATE - INTERVAL '30 days' ORDER BY al.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leurs devis acceptés et factures associées"},{"role":"assistant","content":"SELECT p.*, q.reference as devis_ref, q.total as devis_total, i.reference as facture_ref, i.total_ttc, i.status::invoice_status FROM projects p JOIN quotations q ON p.id = q.project_id LEFT JOIN invoices i ON p.id = i.project_id WHERE q.status::quotation_status = 'accepté' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leurs documents techniques"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('type', de.document_type::document_type, 'content', de.content)) as documents FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id WHERE de.document_type::document_type IN ('plan', 'rapport', 'contrat') GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leurs produits de devis par catégorie"},{"role":"assistant","content":"SELECT p.*, q.reference, array_agg(DISTINCT jsonb_build_object('categorie', qp.category::product_category, 'produit', qp.product_name, 'montant', qp.unit_price * qp.quantity)) as produits FROM projects p JOIN quotations q ON p.id = q.project_id JOIN quotation_products qp ON q.id = qp.quotation_id GROUP BY p.id, q.reference ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leurs paiements par méthode"},{"role":"assistant","content":"SELECT p.*, i.reference, array_agg(DISTINCT jsonb_build_object('methode', pay.payment_method::payment_method, 'montant', pay.amount)) as paiements FROM projects p JOIN invoices i ON p.id = i.project_id JOIN payments pay ON i.id = pay.invoice_id GROUP BY p.id, i.reference ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leurs événements urgents"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('evenement', ce.title, 'date', ce.start_date)) as urgences FROM projects p JOIN calendar_events ce ON p.id = ce.project_id WHERE ce.event_type::event_type = 'intervention_urgente' AND ce.start_date >= CURRENT_DATE GROUP BY p.id ORDER BY ce.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur historique de changements de statut"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('ancien_statut', (al.details->>'old_status')::project_status, 'nouveau_statut', (al.details->>'new_status')::project_status, 'date', al.created_at)) as historique_statuts FROM projects p JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id WHERE al.action::activity_type = 'update' AND al.details ? 'old_status' GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leurs devis refusés et les raisons"},{"role":"assistant","content":"SELECT p.*, q.reference, q.total, q.notes, al.details->>'reason' as raison_refus FROM projects p JOIN quotations q ON p.id = q.project_id JOIN activity_logs al ON al.entity_type = 'quotation' AND al.entity_id = q.id WHERE q.status::quotation_status = 'refusé' AND al.action::activity_type = 'refus' ORDER BY q.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur progression dans les étapes"},{"role":"assistant","content":"SELECT p.*, array_agg(jsonb_build_object('etape', s.name, 'status', s.status, 'progression', CASE WHEN s.end_date IS NOT NULL THEN 100 WHEN s.start_date IS NOT NULL THEN (EXTRACT(DAY FROM CURRENT_DATE - s.start_date)::float / s.duration_days * 100) ELSE 0 END)) as etapes FROM projects p JOIN stages s ON p.id = s.project_id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur rentabilité détaillée"},{"role":"assistant","content":"SELECT p.*, pb.total_budget, (SELECT SUM(q.total) FROM quotations q WHERE q.project_id = p.id AND q.status::quotation_status = 'accepté') as revenus, (SELECT SUM(e.amount) FROM expenses e WHERE e.project_id = p.id) as depenses, (SELECT SUM(te.hours * te.hourly_rate) FROM timesheet_entries te WHERE te.project_id = p.id) as cout_main_oeuvre FROM projects p LEFT JOIN project_budgets pb ON p.id = pb.project_id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leurs équipements et maintenance"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('equipement', e.name, 'statut', e.status, 'derniere_maintenance', mr.maintenance_date, 'prochaine_maintenance', mr.next_maintenance_date)) as equipements FROM projects p JOIN equipment_reservations er ON p.id = er.project_id JOIN equipment e ON er.equipment_id = e.id LEFT JOIN maintenance_records mr ON e.id = mr.equipment_id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.updated_at;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leurs fournisseurs et commandes"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('fournisseur', s.name, 'commande_ref', so.reference, 'montant', so.total_amount, 'statut', so.status, 'livraison_prevue', so.expected_delivery_date)) as commandes FROM projects p JOIN supplier_orders so ON p.id = so.project_id JOIN suppliers s ON so.supplier_id = s.id WHERE p.status::project_status IN ('en_cours', 'en_pause') GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leurs événements de calendrier par type"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('type', ce.event_type::event_type, 'evenements', (SELECT json_agg(json_build_object('titre', c2.title, 'date', c2.start_date)) FROM calendar_events c2 WHERE c2.project_id = p.id AND c2.event_type = ce.event_type))) as calendrier FROM projects p JOIN calendar_events ce ON p.id = ce.project_id WHERE p.status::project_status != 'annule' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur historique complet d'activités"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('date', al.created_at, 'action', al.action::activity_type, 'details', al.details, 'utilisateur', u.firstname || ' ' || u.lastname)) as activites FROM projects p JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id LEFT JOIN users u ON al.user_id = u.id WHERE p.created_at >= CURRENT_DATE - INTERVAL '90 days' GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leurs témoignages clients"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('client', c.firstname || ' ' || c.lastname, 'note', t.rating, 'commentaire', t.comment, 'publie', t.is_published)) as temoignages FROM projects p JOIN testimonials t ON p.id = t.project_id JOIN clients c ON t.client_id = c.id WHERE p.status::project_status = 'termine' GROUP BY p.id ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leurs services standards utilisés"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('service', ss.name, 'categorie', ss.category, 'prix_moyen', (ss.avg_price_min + ss.avg_price_max)/2, 'duree_prevue', ss.avg_duration_days)) as services FROM projects p JOIN quotation_products qp ON p.id = qp.quotation_id JOIN standard_services ss ON qp.product_name ILIKE ss.name WHERE p.status::project_status IN ('prospect', 'en_cours') GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse financière complète"},{"role":"assistant","content":"WITH projet_finances AS (SELECT p.id, SUM(q.total) as total_devis, SUM(i.total_ttc) as total_facture, SUM(pay.amount) as total_paye, SUM(e.amount) as total_depenses FROM projects p LEFT JOIN quotations q ON p.id = q.project_id LEFT JOIN invoices i ON p.id = i.project_id LEFT JOIN payments pay ON i.id = pay.invoice_id LEFT JOIN expenses e ON p.id = e.project_id GROUP BY p.id) SELECT p.*, pf.total_devis, pf.total_facture, pf.total_paye, pf.total_depenses, pb.total_budget, CASE WHEN p.status::project_status = 'termine' THEN ((pf.total_paye - pf.total_depenses) / NULLIF(pb.total_budget, 0) * 100) END as rentabilite_pourcentage FROM projects p LEFT JOIN projet_finances pf ON p.id = pf.id LEFT JOIN project_budgets pb ON p.id = pb.project_id ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leurs documents techniques et métadonnées"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('type', de.document_type::document_type, 'contenu', de.content, 'metadata', p.search_metadata)) as documents, array_agg(DISTINCT jsonb_build_object('terme', tg.term, 'definition', tg.definition)) as glossaire_associe FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id LEFT JOIN technical_glossary tg ON p.search_metadata->>'domaine' = tg.category WHERE p.status::project_status != 'annule' GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Analyse les projets avec leurs KPIs complets"},{"role":"assistant","content":"WITH projet_kpis AS (SELECT p.id, COUNT(DISTINCT q.id) as nb_devis, COUNT(DISTINCT i.id) as nb_factures, COUNT(DISTINCT ce.id) as nb_evenements, COUNT(DISTINCT s.id) as nb_etapes, AVG(t.rating) as satisfaction_moyenne FROM projects p LEFT JOIN quotations q ON p.id = q.project_id LEFT JOIN invoices i ON p.id = i.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN stages s ON p.id = s.project_id LEFT JOIN testimonials t ON p.id = t.project_id GROUP BY p.id) SELECT p.*, pk.*, CASE WHEN p.end_date IS NOT NULL AND p.start_date IS NOT NULL THEN p.end_date - p.start_date ELSE NULL END as duree_reelle FROM projects p JOIN projet_kpis pk ON p.id = pk.id WHERE p.status::project_status != 'annule' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur historique de modifications par type d'activité"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('type_activite', al.action::activity_type, 'modifications', (SELECT json_agg(json_build_object('date', al2.created_at, 'details', al2.details, 'utilisateur', u.firstname || ' ' || u.lastname)) FROM activity_logs al2 JOIN users u ON al2.user_id = u.id WHERE al2.entity_type = 'project' AND al2.entity_id = p.id AND al2.action = al.action ORDER BY al2.created_at DESC))) as historique_modifications FROM projects p JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse de performance équipe"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('membre', s.firstname || ' ' || s.lastname, 'role', ps.role, 'heures_travaillees', SUM(te.hours), 'cout_total', SUM(te.hours * te.hourly_rate), 'evenements_assignes', COUNT(DISTINCT ce.id))) as performance_equipe FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.staff_id = s.id WHERE p.status::project_status = 'en_cours' GROUP BY p.id, s.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur suivi budgétaire détaillé"},{"role":"assistant","content":"WITH budget_suivi AS (SELECT p.id, pb.total_budget, SUM(e.amount) FILTER (WHERE e.category_id IN (SELECT id FROM expense_categories WHERE name LIKE '%matériel%')) as cout_materiel, SUM(te.hours * te.hourly_rate) as cout_main_oeuvre, SUM(e.amount) FILTER (WHERE e.category_id IN (SELECT id FROM expense_categories WHERE name LIKE '%transport%')) as cout_transport FROM projects p LEFT JOIN project_budgets pb ON p.id = pb.project_id LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN timesheet_entries te ON p.id = te.project_id GROUP BY p.id, pb.total_budget) SELECT p.*, bs.*, CASE WHEN bs.total_budget > 0 THEN ((bs.cout_materiel + bs.cout_main_oeuvre + bs.cout_transport) / bs.total_budget * 100) ELSE NULL END as pourcentage_utilisation FROM projects p JOIN budget_suivi bs ON p.id = bs.id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse des risques"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('type_evenement', ce.event_type::event_type, 'urgences', COUNT(*) FILTER (WHERE ce.event_type = 'intervention_urgente'), 'retards', COUNT(*) FILTER (WHERE ce.end_date > ce.start_date + INTERVAL '1 day'), 'conflits', COUNT(*) FILTER (WHERE EXISTS (SELECT 1 FROM calendar_events ce2 WHERE ce2.id != ce.id AND ce2.project_id = p.id AND ce2.start_date < ce.end_date AND ce2.end_date > ce.start_date)))) as analyse_risques FROM projects p LEFT JOIN calendar_events ce ON p.id = ce.project_id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de la chaîne d'approvisionnement"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('fournisseur', s.name, 'commandes', COUNT(so.id), 'delai_moyen', AVG(so.actual_delivery_date - so.order_date), 'montant_total', SUM(so.total_amount), 'retards', COUNT(*) FILTER (WHERE so.actual_delivery_date > so.expected_delivery_date))) as analyse_approvisionnement FROM projects p JOIN supplier_orders so ON p.id = so.project_id JOIN suppliers s ON so.supplier_id = s.id WHERE p.status::project_status IN ('en_cours', 'termine') GROUP BY p.id, s.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse de satisfaction client"},{"role":"assistant","content":"SELECT p.*, c.firstname || ' ' || c.lastname as client_name, array_agg(DISTINCT jsonb_build_object('evaluation', t.rating, 'commentaire', t.comment, 'date', t.created_at, 'interactions', (SELECT COUNT(*) FROM calendar_events ce WHERE ce.project_id = p.id AND ce.client_id = c.id), 'reclamations', (SELECT COUNT(*) FROM activity_logs al WHERE al.entity_type = 'project' AND al.entity_id = p.id AND al.action::activity_type = 'commentaire' AND al.details->>'type' = 'reclamation'))) as satisfaction_client FROM projects p JOIN clients c ON p.client_id = c.id LEFT JOIN testimonials t ON p.id = t.project_id WHERE p.status::project_status IN ('en_cours', 'termine') GROUP BY p.id, c.firstname, c.lastname ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de rentabilité par phase"},{"role":"assistant","content":"WITH phase_rentabilite AS (SELECT p.id, s.name as phase_name, SUM(e.amount) as cout_phase, SUM(te.hours * te.hourly_rate) as cout_main_oeuvre_phase, (SELECT SUM(qp.quantity * qp.unit_price) FROM quotations q JOIN quotation_products qp ON q.id = qp.quotation_id WHERE q.project_id = p.id AND q.status::quotation_status = 'accepté' AND qp.description ILIKE '%' || s.name || '%') as revenu_phase FROM projects p JOIN stages s ON p.id = s.project_id LEFT JOIN expenses e ON p.id = e.project_id AND e.description ILIKE '%' || s.name || '%' LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.description ILIKE '%' || s.name || '%' GROUP BY p.id, s.name) SELECT p.*, array_agg(jsonb_build_object('phase', pr.phase_name, 'rentabilite', COALESCE(pr.revenu_phase, 0) - COALESCE(pr.cout_phase, 0) - COALESCE(pr.cout_main_oeuvre_phase, 0))) as rentabilite_phases FROM projects p JOIN phase_rentabilite pr ON p.id = pr.id GROUP BY p.id ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse des délais"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('etape', s.name, 'duree_prevue', s.duration_days, 'duree_reelle', CASE WHEN s.end_date IS NOT NULL AND s.start_date IS NOT NULL THEN EXTRACT(DAY FROM s.end_date - s.start_date) END, 'retard', CASE WHEN s.end_date > s.start_date + (s.duration_days || ' days')::interval THEN EXTRACT(DAY FROM (s.end_date - (s.start_date + (s.duration_days || ' days')::interval))) END)) as analyse_delais, (SELECT AVG(EXTRACT(DAY FROM (actual_delivery_date - expected_delivery_date))) FROM supplier_orders WHERE project_id = p.id AND actual_delivery_date > expected_delivery_date) as retard_moyen_livraisons FROM projects p LEFT JOIN stages s ON p.id = s.project_id WHERE p.status::project_status IN ('en_cours', 'termine') GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des coûts imprévus"},{"role":"assistant","content":"WITH couts_imprevus AS (SELECT p.id, SUM(e.amount) FILTER (WHERE e.description ILIKE '%imprévu%' OR e.description ILIKE '%urgence%') as total_imprevus, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente') as nb_interventions_urgentes, SUM(te.hours * te.hourly_rate) FILTER (WHERE te.description ILIKE '%urgence%') as cout_main_oeuvre_urgence FROM projects p LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN timesheet_entries te ON p.id = te.project_id GROUP BY p.id) SELECT p.*, ci.*, CASE WHEN pb.total_budget > 0 THEN (ci.total_imprevus / pb.total_budget * 100) END as pourcentage_imprevus_budget FROM projects p JOIN couts_imprevus ci ON p.id = ci.id LEFT JOIN project_budgets pb ON p.id = pb.project_id WHERE p.status::project_status != 'annule' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Analyse les projets avec leurs métriques de communication"},{"role":"assistant","content":"WITH comm_metrics AS (SELECT p.id, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type IN ('appel_telephonique', 'reunion_chantier', 'rendez_vous_client')) as interactions_client, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire') as communications_internes, array_agg(DISTINCT ce.event_type::event_type) as types_communication FROM projects p LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id GROUP BY p.id) SELECT p.*, cm.*, array_agg(jsonb_build_object('mois', date_trunc('month', ce.start_date), 'nb_interactions', COUNT(*))) as frequence_communications FROM projects p JOIN comm_metrics cm ON p.id = cm.id LEFT JOIN calendar_events ce ON p.id = ce.project_id WHERE p.status::project_status = 'en_cours' GROUP BY p.id, cm.interactions_client, cm.communications_internes, cm.types_communication ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de performance fournisseurs"},{"role":"assistant","content":"WITH perf_fournisseurs AS (SELECT p.id, s.id as supplier_id, s.name as supplier_name, AVG(so.actual_delivery_date - so.expected_delivery_date) as retard_moyen, COUNT(DISTINCT so.id) as nb_commandes, SUM(so.total_amount) as montant_total, COUNT(*) FILTER (WHERE so.actual_delivery_date > so.expected_delivery_date) as livraisons_retard FROM projects p JOIN supplier_orders so ON p.id = so.project_id JOIN suppliers s ON so.supplier_id = s.id GROUP BY p.id, s.id, s.name) SELECT p.*, array_agg(jsonb_build_object('fournisseur', pf.supplier_name, 'score_performance', CASE WHEN pf.retard_moyen IS NULL THEN 100 ELSE 100 - (EXTRACT(DAY FROM pf.retard_moyen) * 5) END, 'fiabilite', (pf.nb_commandes - pf.livraisons_retard)::float / NULLIF(pf.nb_commandes, 0) * 100)) as analyse_fournisseurs FROM projects p JOIN perf_fournisseurs pf ON p.id = pf.id GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse des incidents"},{"role":"assistant","content":"WITH incidents AS (SELECT p.id, ce.event_type::event_type, COUNT(*) as nb_incidents, AVG(EXTRACT(EPOCH FROM (ce.end_date - ce.start_date))/3600) as duree_moyenne_resolution FROM projects p JOIN calendar_events ce ON p.id = ce.project_id WHERE ce.event_type::event_type IN ('intervention_urgente', 'maintenance') GROUP BY p.id, ce.event_type) SELECT p.*, array_agg(jsonb_build_object('type', i.event_type, 'nombre', i.nb_incidents, 'temps_resolution', i.duree_moyenne_resolution, 'impact', CASE WHEN i.nb_incidents > 5 THEN 'élevé' WHEN i.nb_incidents > 2 THEN 'moyen' ELSE 'faible' END)) as analyse_incidents, (SELECT COUNT(*) FROM activity_logs al WHERE al.entity_type = 'project' AND al.entity_id = p.id AND al.action::activity_type = 'commentaire' AND al.details->>'urgence' = 'haute') as signalements_urgents FROM projects p LEFT JOIN incidents i ON p.id = i.id WHERE p.status::project_status != 'annule' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de charge de travail"},{"role":"assistant","content":"WITH charge_travail AS (SELECT p.id, s.id as staff_id, s.firstname || ' ' || s.lastname as staff_name, SUM(te.hours) as heures_travaillees, COUNT(DISTINCT ce.id) as taches_assignees, array_agg(DISTINCT ce.event_type::event_type) as types_taches FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.staff_id = s.id GROUP BY p.id, s.id, s.firstname, s.lastname) SELECT p.*, array_agg(jsonb_build_object('membre', ct.staff_name, 'charge', CASE WHEN ct.heures_travaillees > 160 THEN 'surcharge' WHEN ct.heures_travaillees > 120 THEN 'elevee' ELSE 'normale' END, 'repartition_taches', ct.types_taches)) as analyse_charge FROM projects p JOIN charge_travail ct ON p.id = ct.id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse des coûts par catégorie"},{"role":"assistant","content":"WITH couts_categories AS (SELECT p.id, ec.name as categorie, SUM(e.amount) as montant, COUNT(*) as nb_depenses, MAX(e.amount) as depense_max FROM projects p JOIN expenses e ON p.id = e.project_id JOIN expense_categories ec ON e.category_id = ec.id GROUP BY p.id, ec.name), budget_compare AS (SELECT p.id, pb.total_budget, SUM(e.amount) as total_depense, (pb.total_budget - SUM(e.amount)) as budget_restant FROM projects p JOIN project_budgets pb ON p.id = pb.project_id LEFT JOIN expenses e ON p.id = e.project_id GROUP BY p.id, pb.total_budget) SELECT p.*, bc.budget_restant, array_agg(jsonb_build_object('categorie', cc.categorie, 'montant', cc.montant, 'pourcentage_budget', (cc.montant / NULLIF(bc.total_budget, 0) * 100)::numeric(10,2))) as analyse_couts FROM projects p JOIN budget_compare bc ON p.id = bc.id JOIN couts_categories cc ON p.id = cc.id GROUP BY p.id, bc.budget_restant ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des modifications"},{"role":"assistant","content":"WITH modifications AS (SELECT p.id, al.action::activity_type, COUNT(*) as nb_modifications, array_agg(DISTINCT u.firstname || ' ' || u.lastname) as utilisateurs, MAX(al.created_at) as derniere_modif FROM projects p JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id JOIN users u ON al.user_id = u.id WHERE al.action::activity_type IN ('update', 'modification') GROUP BY p.id, al.action) SELECT p.*, array_agg(jsonb_build_object('type_modif', m.action, 'nombre', m.nb_modifications, 'auteurs', m.utilisateurs, 'derniere_date', m.derniere_modif)) as historique_modifications, (SELECT COUNT(*) FROM activity_logs al2 WHERE al2.entity_type = 'project' AND al2.entity_id = p.id AND al2.action::activity_type = 'validation') as validations_totales FROM projects p JOIN modifications m ON p.id = m.id GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse des documents"},{"role":"assistant","content":"SELECT p.*, array_agg(DISTINCT jsonb_build_object('type_doc', de.document_type::document_type, 'nombre', COUNT(*), 'derniere_maj', MAX(de.updated_at), 'auteurs', array_agg(DISTINCT u.firstname || ' ' || u.lastname))) as analyse_documents, (SELECT json_build_object('manquants', array_agg(dt::document_type) FILTER (WHERE dt NOT IN (SELECT document_type FROM document_embeddings WHERE document_id = p.id))) FROM unnest(enum_range(NULL::document_type)) dt) as documents_manquants FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id LEFT JOIN activity_logs al ON al.entity_type = 'document' AND al.entity_id = de.id LEFT JOIN users u ON al.user_id = u.id WHERE p.status::project_status != 'annule' GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse des interactions client"},{"role":"assistant","content":"WITH interactions AS (SELECT p.id, ce.event_type::event_type, COUNT(*) as nb_interactions, array_agg(DISTINCT c.firstname || ' ' || c.lastname) as participants, AVG(t.rating) as satisfaction FROM projects p JOIN calendar_events ce ON p.id = ce.project_id JOIN clients c ON ce.client_id = c.id LEFT JOIN testimonials t ON p.id = t.project_id GROUP BY p.id, ce.event_type) SELECT p.*, array_agg(jsonb_build_object('type_interaction', i.event_type, 'frequence', i.nb_interactions, 'participants', i.participants, 'satisfaction', i.satisfaction)) as analyse_interactions, (SELECT json_build_object('dernier_contact', MAX(ce.start_date), 'prochain_contact', MIN(ce.start_date) FILTER (WHERE ce.start_date > CURRENT_DATE)) FROM calendar_events ce WHERE ce.project_id = p.id) as timeline_contacts FROM projects p JOIN interactions i ON p.id = i.id WHERE p.status::project_status IN ('prospect', 'en_cours') GROUP BY p.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse des étapes critiques"},{"role":"assistant","content":"WITH etapes_critiques AS (SELECT p.id, s.name, s.status, s.duration_days, s.start_date, s.end_date, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente') as urgences, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'modification') as modifications FROM projects p JOIN stages s ON p.id = s.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.start_date BETWEEN s.start_date AND s.end_date LEFT JOIN activity_logs al ON al.entity_type = 'stage' AND al.entity_id = s.id GROUP BY p.id, s.name, s.status, s.duration_days, s.start_date, s.end_date) SELECT p.*, array_agg(jsonb_build_object('etape', ec.name, 'criticite', CASE WHEN ec.urgences > 2 OR (ec.end_date - ec.start_date) > (ec.duration_days || ' days')::interval THEN 'haute' WHEN ec.urgences > 0 OR ec.modifications > 5 THEN 'moyenne' ELSE 'basse' END, 'retard', CASE WHEN ec.end_date > ec.start_date + (ec.duration_days || ' days')::interval THEN EXTRACT(DAY FROM (ec.end_date - (ec.start_date + (ec.duration_days || ' days')::interval))) ELSE 0 END)) as analyse_etapes_critiques FROM projects p JOIN etapes_critiques ec ON p.id = ec.id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des ressources critiques"},{"role":"assistant","content":"WITH ressources_critiques AS (SELECT p.id, e.name as equipment_name, e.status as equipment_status, COUNT(DISTINCT er.id) as reservations, array_agg(DISTINCT s.firstname || ' ' || s.lastname) as utilisateurs, MAX(mr.maintenance_date) as derniere_maintenance, MIN(mr.next_maintenance_date) as prochaine_maintenance FROM projects p JOIN equipment_reservations er ON p.id = er.project_id JOIN equipment e ON er.equipment_id = e.id LEFT JOIN staff s ON er.staff_id = s.id LEFT JOIN maintenance_records mr ON e.id = mr.equipment_id GROUP BY p.id, e.name, e.status) SELECT p.*, array_agg(jsonb_build_object('equipement', rc.equipment_name, 'disponibilite', rc.equipment_status, 'utilisation', rc.reservations, 'operateurs', rc.utilisateurs, 'maintenance_status', CASE WHEN rc.prochaine_maintenance < CURRENT_DATE THEN 'maintenance_requise' WHEN rc.prochaine_maintenance < CURRENT_DATE + INTERVAL '7 days' THEN 'maintenance_proche' ELSE 'ok' END)) as analyse_ressources FROM projects p JOIN ressources_critiques rc ON p.id = rc.id WHERE p.status::project_status IN ('en_cours', 'en_pause') GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Analyse les projets avec leurs indicateurs de performance globale"},{"role":"assistant","content":"WITH kpi_global AS (SELECT p.id, COUNT(DISTINCT q.id) FILTER (WHERE q.status::quotation_status = 'accepté') as devis_gagnes, AVG(t.rating) as satisfaction_moyenne, SUM(te.hours) as heures_totales, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente') as incidents, (SELECT COUNT(*) FROM invoices i WHERE i.project_id = p.id AND i.status::invoice_status = 'payée') as factures_payees FROM projects p LEFT JOIN quotations q ON p.id = q.project_id LEFT JOIN testimonials t ON p.id = t.project_id LEFT JOIN timesheet_entries te ON p.id = te.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id GROUP BY p.id) SELECT p.*, kg.*, jsonb_build_object('performance_score', (COALESCE(kg.devis_gagnes, 0) * 20 + COALESCE(kg.satisfaction_moyenne, 0) * 20 - COALESCE(kg.incidents, 0) * 10 + COALESCE(kg.factures_payees, 0) * 15) / NULLIF(kg.heures_totales, 0)) as score_global FROM projects p JOIN kpi_global kg ON p.id = kg.id WHERE p.status::project_status != 'annule' ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de rentabilité par service"},{"role":"assistant","content":"WITH rentabilite_services AS (SELECT p.id, qp.product_name, qp.category::product_category, SUM(qp.quantity * qp.unit_price) as revenu, SUM(e.amount) FILTER (WHERE e.description ILIKE '%' || qp.product_name || '%') as cout_direct, SUM(te.hours * te.hourly_rate) FILTER (WHERE te.description ILIKE '%' || qp.product_name || '%') as cout_main_oeuvre FROM projects p JOIN quotations q ON p.id = q.project_id JOIN quotation_products qp ON q.id = qp.quotation_id LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN timesheet_entries te ON p.id = te.project_id GROUP BY p.id, qp.product_name, qp.category) SELECT p.*, array_agg(jsonb_build_object('service', rs.product_name, 'categorie', rs.category, 'marge', rs.revenu - COALESCE(rs.cout_direct, 0) - COALESCE(rs.cout_main_oeuvre, 0), 'rentabilite_pourcentage', ((rs.revenu - COALESCE(rs.cout_direct, 0) - COALESCE(rs.cout_main_oeuvre, 0)) / NULLIF(rs.revenu, 0) * 100)::numeric(10,2))) as analyse_rentabilite_services FROM projects p JOIN rentabilite_services rs ON p.id = rs.id GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse des compétences utilisées"},{"role":"assistant","content":"WITH competences_projet AS (SELECT p.id, s.role, COUNT(DISTINCT s.id) as nb_staff, array_agg(DISTINCT s.firstname || ' ' || s.lastname) as staff_implique, SUM(te.hours) as heures_par_role, array_agg(DISTINCT e.name) FILTER (WHERE e.category_id IN (SELECT id FROM equipment_categories WHERE name ILIKE '%' || s.role || '%')) as equipements_associes FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id LEFT JOIN equipment_reservations er ON p.id = er.project_id LEFT JOIN equipment e ON er.equipment_id = e.id GROUP BY p.id, s.role) SELECT p.*, array_agg(jsonb_build_object('role', cp.role, 'effectif', cp.nb_staff, 'equipe', cp.staff_implique, 'charge_travail', cp.heures_par_role, 'equipements', cp.equipements_associes)) as analyse_competences FROM projects p JOIN competences_projet cp ON p.id = cp.id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse des risques opérationnels"},{"role":"assistant","content":"WITH risques_op AS (SELECT p.id, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type IN ('intervention_urgente', 'maintenance')) as incidents_techniques, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire' AND al.details->>'type' = 'risque') as signalements_risques, array_agg(DISTINCT jsonb_build_object('type', mr.maintenance_type, 'equipement', e.name)) FILTER (WHERE mr.maintenance_type ILIKE '%preventif%') as maintenances_preventives FROM projects p LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id LEFT JOIN equipment_reservations er ON p.id = er.project_id LEFT JOIN equipment e ON er.equipment_id = e.id LEFT JOIN maintenance_records mr ON e.id = mr.equipment_id GROUP BY p.id) SELECT p.*, ro.*, jsonb_build_object('niveau_risque', CASE WHEN ro.incidents_techniques > 5 OR ro.signalements_risques > 3 THEN 'élevé' WHEN ro.incidents_techniques > 2 OR ro.signalements_risques > 1 THEN 'moyen' ELSE 'faible' END) as evaluation_risque FROM projects p JOIN risques_op ro ON p.id = ro.id WHERE p.status::project_status IN ('en_cours', 'en_pause') ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse de conformité réglementaire"},{"role":"assistant","content":"WITH conformite AS (SELECT p.id, array_agg(DISTINCT de.document_type::document_type) FILTER (WHERE de.document_type::document_type IN ('contrat', 'rapport')) as documents_obligatoires, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'validation') as validations_reglementaires, bool_or(t.rating IS NOT NULL) as evaluation_client_presente FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id LEFT JOIN testimonials t ON p.id = t.project_id GROUP BY p.id) SELECT p.*, c.*, jsonb_build_object('statut_conformite', CASE WHEN array_length(c.documents_obligatoires, 1) >= 2 AND c.validations_reglementaires > 0 AND c.evaluation_client_presente THEN 'conforme' WHEN array_length(c.documents_obligatoires, 1) >= 1 THEN 'partiel' ELSE 'non_conforme' END) as evaluation_conformite FROM projects p JOIN conformite c ON p.id = c.id WHERE p.status::project_status != 'annule' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de satisfaction client détaillée"},{"role":"assistant","content":"WITH satisfaction_details AS (SELECT p.id, AVG(t.rating) as note_moyenne, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type IN ('appel_telephonique', 'rendez_vous_client')) as interactions_client, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire' AND al.details->>'sentiment' = 'positif') as retours_positifs, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire' AND al.details->>'sentiment' = 'negatif') as retours_negatifs FROM projects p LEFT JOIN testimonials t ON p.id = t.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id GROUP BY p.id) SELECT p.*, sd.*, jsonb_build_object('indice_satisfaction', ((COALESCE(sd.note_moyenne, 0) * 20 + (sd.retours_positifs - sd.retours_negatifs) * 10) / NULLIF(sd.interactions_client, 0))::numeric(10,2)) as score_satisfaction FROM projects p JOIN satisfaction_details sd ON p.id = sd.id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY p.end_date DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse des délais de livraison"},{"role":"assistant","content":"WITH delais_livraison AS (SELECT p.id, AVG(so.actual_delivery_date - so.order_date) as delai_moyen_livraison, COUNT(DISTINCT so.id) FILTER (WHERE so.actual_delivery_date > so.expected_delivery_date) as retards_livraison, MAX(so.actual_delivery_date - so.expected_delivery_date) as retard_max, array_agg(DISTINCT s.name) FILTER (WHERE so.actual_delivery_date > so.expected_delivery_date) as fournisseurs_retard FROM projects p JOIN supplier_orders so ON p.id = so.project_id JOIN suppliers s ON so.supplier_id = s.id GROUP BY p.id) SELECT p.*, dl.*, jsonb_build_object('performance_livraison', CASE WHEN dl.retards_livraison = 0 THEN 'excellent' WHEN dl.retards_livraison <= 2 THEN 'bon' ELSE 'à_améliorer' END) as evaluation_livraisons FROM projects p JOIN delais_livraison dl ON p.id = dl.id WHERE p.status::project_status = 'en_cours' ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse des coûts cachés"},{"role":"assistant","content":"WITH couts_caches AS (SELECT p.id, SUM(e.amount) FILTER (WHERE e.description ILIKE '%imprévu%' OR e.description ILIKE '%supplémentaire%') as depenses_imprevues, SUM(te.hours * te.hourly_rate) FILTER (WHERE te.description ILIKE '%correction%' OR te.description ILIKE '%reprise%') as cout_corrections, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente') * 500 as cout_urgences FROM projects p LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN timesheet_entries te ON p.id = te.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id GROUP BY p.id) SELECT p.*, cc.*, jsonb_build_object('impact_budget', ((cc.depenses_imprevues + cc.cout_corrections + cc.cout_urgences) / NULLIF((SELECT total_budget FROM project_budgets WHERE project_id = p.id), 0) * 100)::numeric(10,2)) as pourcentage_impact FROM projects p JOIN couts_caches cc ON p.id = cc.id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse de productivité détaillée"},{"role":"assistant","content":"WITH productivite AS (SELECT p.id, COUNT(DISTINCT s.id) as effectif_total, SUM(te.hours) as heures_totales, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type NOT IN ('absence', 'maintenance')) as taches_realisees, (SELECT total_budget FROM project_budgets WHERE project_id = p.id) as budget_initial FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN timesheet_entries te ON p.id = te.project_id LEFT JOIN calendar_events ce ON p.id = ce.project_id GROUP BY p.id) SELECT p.*, pr.*, jsonb_build_object('productivite_horaire', (pr.taches_realisees::float / NULLIF(pr.heures_totales, 0))::numeric(10,2), 'cout_par_tache', (pr.budget_initial::float / NULLIF(pr.taches_realisees, 0))::numeric(10,2), 'efficacite_equipe', (pr.taches_realisees::float / (pr.effectif_total * pr.heures_totales))::numeric(10,4)) as indicateurs_productivite FROM projects p JOIN productivite pr ON p.id = pr.id WHERE p.status::project_status = 'en_cours' ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des opportunités d'amélioration"},{"role":"assistant","content":"WITH opportunites AS (SELECT p.id, array_agg(DISTINCT jsonb_build_object('domaine', CASE WHEN al.action::activity_type = 'commentaire' AND al.details->>'type' = 'suggestion' THEN 'suggestion' WHEN ce.event_type::event_type = 'intervention_urgente' THEN 'prevention' WHEN t.rating < 4 THEN 'satisfaction' END, 'description', COALESCE(al.details->>'message', ce.description, t.comment))) as points_amelioration, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire' AND al.details->>'type' = 'suggestion') as nb_suggestions, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente') as nb_incidents FROM projects p LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN testimonials t ON p.id = t.project_id GROUP BY p.id) SELECT p.*, o.*, jsonb_build_object('priorite_amelioration', CASE WHEN o.nb_incidents > 3 OR o.nb_suggestions > 5 THEN 'haute' WHEN o.nb_incidents > 0 OR o.nb_suggestions > 2 THEN 'moyenne' ELSE 'basse' END) as evaluation_opportunites FROM projects p JOIN opportunites o ON p.id = o.id WHERE p.status::project_status != 'annule' ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Analyse les projets avec leur suivi qualité complet"},{"role":"assistant","content":"WITH qualite_suivi AS (SELECT p.id, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'validation') as validations_qualite, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'maintenance') as controles_qualite, array_agg(DISTINCT jsonb_build_object('etape', s.name, 'defauts_detectes', COUNT(al2.id) FILTER (WHERE al2.action::activity_type = 'commentaire' AND al2.details->>'type' = 'defaut'))) as defauts_par_etape FROM projects p LEFT JOIN stages s ON p.id = s.project_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id LEFT JOIN activity_logs al2 ON al2.entity_type = 'stage' AND al2.entity_id = s.id LEFT JOIN calendar_events ce ON p.id = ce.project_id GROUP BY p.id) SELECT p.*, qs.*, jsonb_build_object('indice_qualite', (100 - (COALESCE((SELECT SUM(value->>'defauts_detectes')::int FROM jsonb_array_elements(qs.defauts_par_etape)) * 5, 0)))::numeric(10,2)) as score_qualite FROM projects p JOIN qualite_suivi qs ON p.id = qs.id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des retards cumulés"},{"role":"assistant","content":"WITH retards_analyse AS (SELECT p.id, SUM(CASE WHEN s.end_date > s.start_date + (s.duration_days || ' days')::interval THEN EXTRACT(DAY FROM (s.end_date - (s.start_date + (s.duration_days || ' days')::interval))) ELSE 0 END) as retard_total_jours, COUNT(DISTINCT s.id) FILTER (WHERE s.end_date > s.start_date + (s.duration_days || ' days')::interval) as nb_etapes_retard, array_agg(DISTINCT jsonb_build_object('etape', s.name, 'retard_jours', EXTRACT(DAY FROM (s.end_date - (s.start_date + (s.duration_days || ' days')::interval))), 'impact', CASE WHEN EXISTS (SELECT 1 FROM stages s2 WHERE s2.project_id = p.id AND s2.start_date > s.end_date) THEN 'critique' ELSE 'normal' END)) FILTER (WHERE s.end_date > s.start_date + (s.duration_days || ' days')::interval) as details_retards FROM projects p JOIN stages s ON p.id = s.project_id GROUP BY p.id) SELECT p.*, ra.*, jsonb_build_object('impact_planning', CASE WHEN ra.retard_total_jours > 30 THEN 'severe' WHEN ra.retard_total_jours > 15 THEN 'important' ELSE 'modere' END) as evaluation_impact FROM projects p JOIN retards_analyse ra ON p.id = ra.id WHERE p.status::project_status = 'en_cours' ORDER BY ra.retard_total_jours DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse des coûts par intervenant"},{"role":"assistant","content":"WITH couts_intervenants AS (SELECT p.id, s.id as staff_id, s.firstname || ' ' || s.lastname as intervenant, s.role, SUM(te.hours * te.hourly_rate) as cout_main_oeuvre, COUNT(DISTINCT ce.id) as nb_interventions, array_agg(DISTINCT jsonb_build_object('type_intervention', ce.event_type::event_type, 'duree', EXTRACT(HOUR FROM (ce.end_date - ce.start_date)))) as details_interventions FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.staff_id = s.id GROUP BY p.id, s.id, s.firstname, s.lastname, s.role) SELECT p.*, array_agg(jsonb_build_object('intervenant', ci.intervenant, 'role', ci.role, 'cout_total', ci.cout_main_oeuvre, 'productivite', ci.nb_interventions::float / NULLIF(ci.cout_main_oeuvre, 0), 'interventions', ci.details_interventions)) as analyse_couts_intervenants FROM projects p JOIN couts_intervenants ci ON p.id = ci.id GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse des risques financiers détaillée"},{"role":"assistant","content":"WITH risques_financiers AS (SELECT p.id, pb.total_budget, SUM(e.amount) as depenses_actuelles, SUM(q.total) FILTER (WHERE q.status::quotation_status = 'accepté') as revenus_prevus, array_agg(DISTINCT jsonb_build_object('type_risque', CASE WHEN e.amount > (pb.total_budget * 0.1) THEN 'depassement_budget' WHEN i.status::invoice_status = 'en_retard' THEN 'retard_paiement' WHEN q.status::quotation_status = 'refusé' THEN 'perte_revenue' END, 'montant', CASE WHEN e.amount > (pb.total_budget * 0.1) THEN e.amount WHEN i.status::invoice_status = 'en_retard' THEN i.total_ttc WHEN q.status::quotation_status = 'refusé' THEN q.total END)) FILTER (WHERE e.amount > (pb.total_budget * 0.1) OR i.status::invoice_status = 'en_retard' OR q.status::quotation_status = 'refusé') as risques_identifies FROM projects p LEFT JOIN project_budgets pb ON p.id = pb.project_id LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN quotations q ON p.id = q.project_id LEFT JOIN invoices i ON p.id = i.project_id GROUP BY p.id, pb.total_budget) SELECT p.*, rf.*, jsonb_build_object('niveau_risque_global', CASE WHEN rf.depenses_actuelles > rf.total_budget THEN 'critique' WHEN rf.depenses_actuelles > (rf.total_budget * 0.8) THEN 'eleve' ELSE 'normal' END) as evaluation_risque FROM projects p JOIN risques_financiers rf ON p.id = rf.id WHERE p.status::project_status != 'annule' ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse des performances équipements"},{"role":"assistant","content":"WITH perf_equipements AS (SELECT p.id, e.id as equipment_id, e.name as equipment_name, COUNT(DISTINCT er.id) as nb_utilisations, SUM(EXTRACT(EPOCH FROM (er.end_date - er.start_date))/3600) as heures_utilisation, COUNT(DISTINCT mr.id) as nb_maintenances, array_agg(DISTINCT jsonb_build_object('type_maintenance', mr.maintenance_type, 'cout', mr.cost)) as couts_maintenance, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente') as pannes FROM projects p JOIN equipment_reservations er ON p.id = er.project_id JOIN equipment e ON er.equipment_id = e.id LEFT JOIN maintenance_records mr ON e.id = mr.equipment_id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.description ILIKE '%' || e.name || '%' GROUP BY p.id, e.id, e.name) SELECT p.*, array_agg(jsonb_build_object('equipement', pe.equipment_name, 'taux_utilisation', pe.heures_utilisation / NULLIF(EXTRACT(EPOCH FROM (p.end_date - p.start_date))/3600, 'fiabilite', 100 - (pe.pannes::float / NULLIF(pe.nb_utilisations, 0) * 100), 'cout_maintenance_moyen', (SELECT AVG((value->>'cout')::numeric) FROM jsonb_array_elements(pe.couts_maintenance)))) as analyse_equipements FROM projects p JOIN perf_equipements pe ON p.id = pe.id WHERE p.status::project_status = 'en_cours' GROUP BY p.id ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des compétences requises vs disponibles"},{"role":"assistant","content":"WITH competences_analyse AS (SELECT p.id, s.role, COUNT(DISTINCT s.id) as staff_disponible, COUNT(DISTINCT ps.staff_id) as staff_assigne, array_agg(DISTINCT jsonb_build_object('competence', s.role, 'niveau_requis', CASE WHEN ce.event_type::event_type IN ('intervention_urgente', 'maintenance') THEN 'expert' WHEN ce.event_type::event_type IN ('reunion_chantier', 'visite_technique') THEN 'intermediaire' ELSE 'standard' END)) as competences_necessaires FROM projects p LEFT JOIN staff s ON s.is_available = true LEFT JOIN project_staff ps ON p.id = ps.project_id AND ps.staff_id = s.id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.staff_id = s.id GROUP BY p.id, s.role) SELECT p.*, array_agg(jsonb_build_object('role', ca.role, 'couverture', (ca.staff_assigne::float / NULLIF(ca.staff_disponible, 0) * 100)::numeric(10,2), 'competences', ca.competences_necessaires)) as analyse_competences, CASE WHEN EXISTS (SELECT 1 FROM competences_analyse ca2 WHERE ca2.id = p.id AND ca2.staff_assigne < ca2.staff_disponible) THEN 'incomplet' ELSE 'complet' END as statut_staffing FROM projects p JOIN competences_analyse ca ON p.id = ca.id WHERE p.status::project_status IN ('prospect', 'en_cours') GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse des communications client"},{"role":"assistant","content":"WITH comm_client AS (SELECT p.id, c.firstname || ' ' || c.lastname as client_name, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type IN ('appel_telephonique', 'rendez_vous_client')) as nb_interactions_directes, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire') as nb_feedbacks, array_agg(DISTINCT jsonb_build_object('type_comm', ce.event_type::event_type, 'date', ce.start_date, 'suivi', EXISTS (SELECT 1 FROM activity_logs al2 WHERE al2.entity_type = 'calendar_event' AND al2.entity_id = ce.id AND al2.action::activity_type = 'commentaire'))) as historique_communications FROM projects p JOIN clients c ON p.client_id = c.id LEFT JOIN calendar_events ce ON p.id = ce.project_id AND ce.client_id = c.id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id GROUP BY p.id, c.firstname, c.lastname) SELECT p.*, cc.*, jsonb_build_object('qualite_communication', CASE WHEN cc.nb_interactions_directes > 10 AND cc.nb_feedbacks > 5 THEN 'excellente' WHEN cc.nb_interactions_directes > 5 THEN 'bonne' ELSE 'à_améliorer' END) as evaluation_communication FROM projects p JOIN comm_client cc ON p.id = cc.id WHERE p.status::project_status != 'annule' ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse des délais de validation"},{"role":"assistant","content":"WITH validations_analyse AS (SELECT p.id, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'validation') as nb_validations_total, AVG(EXTRACT(EPOCH FROM (al2.created_at - al.created_at))/3600) FILTER (WHERE al2.action::activity_type = 'validation' AND al.action::activity_type = 'creation') as delai_moyen_validation, array_agg(DISTINCT jsonb_build_object('document', de.document_type::document_type, 'delai_validation', EXTRACT(EPOCH FROM (al2.created_at - al.created_at))/3600)) FILTER (WHERE al2.action::activity_type = 'validation' AND al.action::activity_type = 'creation') as details_validations FROM projects p LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id LEFT JOIN activity_logs al2 ON al2.entity_type = al.entity_type AND al2.entity_id = al.entity_id LEFT JOIN document_embeddings de ON p.id = de.document_id GROUP BY p.id) SELECT p.*, va.*, jsonb_build_object('performance_validation', CASE WHEN va.delai_moyen_validation < 24 THEN 'rapide' WHEN va.delai_moyen_validation < 72 THEN 'normal' ELSE 'lent' END) as evaluation_delais FROM projects p JOIN validations_analyse va ON p.id = va.id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY va.delai_moyen_validation ASC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse des coûts énergétiques"},{"role":"assistant","content":"WITH couts_energie AS (SELECT p.id, SUM(e.amount) FILTER (WHERE e.description ILIKE '%energie%' OR e.description ILIKE '%électricité%' OR e.description ILIKE '%carburant%') as cout_energie_total, COUNT(DISTINCT er.id) FILTER (WHERE e.name ILIKE '%économie%' OR e.name ILIKE '%énergie%') as equipements_eco, array_agg(DISTINCT jsonb_build_object('type_depense', CASE WHEN e.description ILIKE '%électricité%' THEN 'electricite' WHEN e.description ILIKE '%carburant%' THEN 'carburant' ELSE 'autre_energie' END, 'montant', e.amount)) FILTER (WHERE e.description ILIKE '%energie%' OR e.description ILIKE '%électricité%' OR e.description ILIKE '%carburant%') as details_couts FROM projects p LEFT JOIN expenses e ON p.id = e.project_id LEFT JOIN equipment_reservations er ON p.id = er.project_id LEFT JOIN equipment e ON er.equipment_id = e.id GROUP BY p.id) SELECT p.*, ce.*, jsonb_build_object('efficacite_energetique', CASE WHEN ce.equipements_eco > 2 THEN 'haute' WHEN ce.equipements_eco > 0 THEN 'moyenne' ELSE 'basse' END, 'cout_energie_par_jour', ce.cout_energie_total / NULLIF(EXTRACT(DAY FROM (p.end_date - p.start_date)), 0)) as analyse_energie FROM projects p JOIN couts_energie ce ON p.id = ce.id WHERE p.status::project_status IN ('en_cours', 'termine') ORDER BY ce.cout_energie_total DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse des incidents de sécurité"},{"role":"assistant","content":"WITH securite_analyse AS (SELECT p.id, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente' AND ce.description ILIKE '%securité%') as incidents_securite, array_agg(DISTINCT jsonb_build_object('type_incident', CASE WHEN ce.description ILIKE '%accès%' THEN 'acces' WHEN ce.description ILIKE '%vol%' THEN 'vol' WHEN ce.description ILIKE '%dégradation%' THEN 'degradation' ELSE 'autre' END, 'date', ce.start_date, 'resolution', ce.end_date - ce.start_date)) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente' AND ce.description ILIKE '%securité%') as details_incidents, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'validation' AND al.details->>'type' = 'securite') as controles_securite FROM projects p LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id GROUP BY p.id) SELECT p.*, sa.*, jsonb_build_object('niveau_securite', CASE WHEN sa.incidents_securite = 0 THEN 'optimal' WHEN sa.incidents_securite <= 2 THEN 'acceptable' ELSE 'préoccupant' END) as evaluation_securite FROM projects p JOIN securite_analyse sa ON p.id = sa.id WHERE p.status::project_status != 'annule' ORDER BY sa.incidents_securite DESC;"}]}
{"messages":[{"role":"user","content":"Analyse les projets avec leurs indicateurs environnementaux"},{"role":"assistant","content":"WITH eco_metrics AS (SELECT p.id, COUNT(DISTINCT m.id) FILTER (WHERE m.description ILIKE '%recyclé%' OR m.description ILIKE '%durable%') as materiaux_eco, SUM(pm.quantity * m.price) FILTER (WHERE m.description ILIKE '%eco%') as investissement_vert, array_agg(DISTINCT jsonb_build_object('initiative', CASE WHEN e.description ILIKE '%energie%' THEN 'économie_energie' WHEN e.description ILIKE '%eau%' THEN 'gestion_eau' ELSE 'autre' END, 'montant', e.amount)) as actions_environnementales FROM projects p LEFT JOIN project_materials pm ON p.id = pm.project_id LEFT JOIN materials m ON pm.material_id = m.id LEFT JOIN expenses e ON p.id = e.project_id WHERE e.description ILIKE ANY(ARRAY['%eco%', '%durable%', '%environnement%']) GROUP BY p.id) SELECT p.*, em.*, jsonb_build_object('score_environnemental', CASE WHEN em.materiaux_eco > 5 AND em.investissement_vert > 1000 THEN 'excellent' WHEN em.materiaux_eco > 2 THEN 'bon' ELSE 'standard' END) as evaluation_environnementale FROM projects p LEFT JOIN eco_metrics em ON p.id = em.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse d'innovation technologique"},{"role":"assistant","content":"WITH innovation_analyse AS (SELECT p.id, COUNT(DISTINCT e.id) FILTER (WHERE e.description ILIKE '%nouveau%' OR e.description ILIKE '%innovation%') as equipements_innovants, array_agg(DISTINCT jsonb_build_object('technologie', e.name, 'impact', CASE WHEN te.hours < 20 THEN 'facile' WHEN te.hours < 40 THEN 'modéré' ELSE 'complexe' END)) as technologies_utilisees FROM projects p LEFT JOIN equipment_reservations er ON p.id = er.project_id LEFT JOIN equipment e ON er.equipment_id = e.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.description ILIKE '%formation%' GROUP BY p.id) SELECT p.*, ia.*, jsonb_build_object('niveau_innovation', CASE WHEN ia.equipements_innovants > 3 THEN 'pionnier' WHEN ia.equipements_innovants > 0 THEN 'moderne' ELSE 'standard' END) as evaluation_innovation FROM projects p LEFT JOIN innovation_analyse ia ON p.id = ia.id WHERE p.status::project_status != 'annule' ORDER BY ia.equipements_innovants DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de conformité RGPD"},{"role":"assistant","content":"WITH rgpd_analyse AS (SELECT p.id, COUNT(DISTINCT de.id) FILTER (WHERE de.document_type::document_type = 'contrat' AND de.content ILIKE '%rgpd%') as documents_conformes, array_agg(DISTINCT jsonb_build_object('type_donnee', CASE WHEN c.email IS NOT NULL THEN 'email' WHEN c.phone IS NOT NULL THEN 'telephone' ELSE 'autre' END, 'protection', CASE WHEN al.action::activity_type = 'validation' THEN 'validé' ELSE 'en_attente' END)) as donnees_personnelles FROM projects p JOIN clients c ON p.client_id = c.id LEFT JOIN document_embeddings de ON p.id = de.document_id LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id AND al.details->>'type' = 'rgpd' GROUP BY p.id) SELECT p.*, ra.*, jsonb_build_object('statut_rgpd', CASE WHEN ra.documents_conformes > 0 THEN 'conforme' ELSE 'à_verifier' END) as conformite_rgpd FROM projects p JOIN rgpd_analyse ra ON p.id = ra.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse de formation et montée en compétences"},{"role":"assistant","content":"WITH formation_analyse AS (SELECT p.id, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'formation') as sessions_formation, array_agg(DISTINCT jsonb_build_object('competence', s.role, 'heures_formation', SUM(te.hours) FILTER (WHERE te.description ILIKE '%formation%'), 'staff_forme', array_agg(DISTINCT s.firstname || ' ' || s.lastname))) as details_formation FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id GROUP BY p.id, s.role) SELECT p.*, fa.*, jsonb_build_object('impact_formation', CASE WHEN fa.sessions_formation > 5 THEN 'significatif' WHEN fa.sessions_formation > 0 THEN 'modéré' ELSE 'minimal' END) as evaluation_formation FROM projects p JOIN formation_analyse fa ON p.id = fa.id WHERE p.status::project_status = 'en_cours' ORDER BY fa.sessions_formation DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse de satisfaction fournisseurs"},{"role":"assistant","content":"WITH satisfaction_fournisseurs AS (SELECT p.id, s.name as supplier_name, COUNT(DISTINCT so.id) as nb_commandes, AVG(CASE WHEN so.actual_delivery_date <= so.expected_delivery_date THEN 1 ELSE 0 END) as taux_respect_delais, array_agg(DISTINCT jsonb_build_object('evaluation', CASE WHEN pay.payment_date <= i.due_date THEN 'positif' ELSE 'negatif' END, 'delai_paiement', pay.payment_date - i.due_date)) as historique_paiements FROM projects p JOIN supplier_orders so ON p.id = so.project_id JOIN suppliers s ON so.supplier_id = s.id LEFT JOIN invoices i ON p.id = i.project_id LEFT JOIN payments pay ON i.id = pay.invoice_id GROUP BY p.id, s.name) SELECT p.*, array_agg(jsonb_build_object('fournisseur', sf.supplier_name, 'satisfaction', CASE WHEN sf.taux_respect_delais >= 0.8 THEN 'élevée' WHEN sf.taux_respect_delais >= 0.5 THEN 'moyenne' ELSE 'faible' END)) as analyse_satisfaction_fournisseurs FROM projects p JOIN satisfaction_fournisseurs sf ON p.id = sf.id GROUP BY p.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse d'impact social"},{"role":"assistant","content":"WITH impact_social AS (SELECT p.id, COUNT(DISTINCT s.id) FILTER (WHERE s.role ILIKE '%apprenti%' OR s.role ILIKE '%stagiaire%') as emplois_formation, array_agg(DISTINCT jsonb_build_object('type_impact', CASE WHEN e.description ILIKE '%local%' THEN 'economie_locale' WHEN e.description ILIKE '%social%' THEN 'action_sociale' ELSE 'autre' END, 'montant', e.amount)) as initiatives_sociales FROM projects p LEFT JOIN project_staff ps ON p.id = ps.project_id LEFT JOIN staff s ON ps.staff_id = s.id LEFT JOIN expenses e ON p.id = e.project_id WHERE e.description ILIKE ANY(ARRAY['%social%', '%communauté%', '%local%']) GROUP BY p.id) SELECT p.*, is.*, jsonb_build_object('score_social', CASE WHEN is.emplois_formation > 2 THEN 'fort' WHEN is.emplois_formation > 0 THEN 'moyen' ELSE 'standard' END) as evaluation_sociale FROM projects p LEFT JOIN impact_social is ON p.id = is.id ORDER BY p.start_date DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de gestion des connaissances"},{"role":"assistant","content":"WITH knowledge_analyse AS (SELECT p.id, COUNT(DISTINCT de.id) FILTER (WHERE de.document_type::document_type IN ('rapport', 'plan')) as documents_techniques, array_agg(DISTINCT jsonb_build_object('domaine', tg.category, 'termes', array_agg(DISTINCT tg.term))) as glossaire_projet, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'commentaire' AND al.details->>'type' = 'retour_experience') as retours_experience FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id LEFT JOIN technical_glossary tg ON p.search_metadata->>'domaine' = tg.category LEFT JOIN activity_logs al ON al.entity_type = 'project' AND al.entity_id = p.id GROUP BY p.id) SELECT p.*, ka.*, jsonb_build_object('maturite_knowledge', CASE WHEN ka.documents_techniques > 10 AND ka.retours_experience > 5 THEN 'avancée' WHEN ka.documents_techniques > 5 THEN 'intermédiaire' ELSE 'basique' END) as evaluation_knowledge FROM projects p JOIN knowledge_analyse ka ON p.id = ka.id ORDER BY p.updated_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse de résilience"},{"role":"assistant","content":"WITH resilience_analyse AS (SELECT p.id, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'intervention_urgente' AND ce.end_date - ce.start_date < interval '24 hours') as incidents_resolus_rapidement, array_agg(DISTINCT jsonb_build_object('type_incident', ce.description, 'temps_resolution', ce.end_date - ce.start_date, 'impact', CASE WHEN EXISTS (SELECT 1 FROM stages s WHERE s.project_id = p.id AND s.end_date > s.duration_days) THEN 'avec_retard' ELSE 'sans_retard' END)) as gestion_incidents FROM projects p LEFT JOIN calendar_events ce ON p.id = ce.project_id WHERE ce.event_type::event_type = 'intervention_urgente' GROUP BY p.id) SELECT p.*, ra.*, jsonb_build_object('niveau_resilience', CASE WHEN ra.incidents_resolus_rapidement > (SELECT COUNT(*) FROM calendar_events WHERE project_id = p.id AND event_type::event_type = 'intervention_urgente') * 0.8 THEN 'forte' WHEN ra.incidents_resolus_rapidement > 0 THEN 'moyenne' ELSE 'à_améliorer' END) as evaluation_resilience FROM projects p LEFT JOIN resilience_analyse ra ON p.id = ra.id WHERE p.status::project_status = 'en_cours' ORDER BY p.start_date;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de digitalisation"},{"role":"assistant","content":"WITH digital_analyse AS (SELECT p.id, COUNT(DISTINCT de.id) FILTER (WHERE de.document_type::document_type != 'autre') as documents_numerises, array_agg(DISTINCT jsonb_build_object('outil_digital', CASE WHEN ce.description ILIKE '%visio%' THEN 'visioconference' WHEN ce.description ILIKE '%digital%' THEN 'outil_collaboratif' ELSE 'autre' END, 'utilisation', COUNT(*))) as outils_utilises FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id LEFT JOIN calendar_events ce ON p.id = ce.project_id WHERE ce.description ILIKE ANY(ARRAY['%digital%', '%visio%', '%en ligne%']) GROUP BY p.id) SELECT p.*, da.*, jsonb_build_object('niveau_digitalisation', CASE WHEN da.documents_numerises > 20 THEN 'avancé' WHEN da.documents_numerises > 10 THEN 'intermédiaire' ELSE 'basique' END) as evaluation_digital FROM projects p LEFT JOIN digital_analyse da ON p.id = da.id ORDER BY da.documents_numerises DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de mobilité et déplacements"},{"role":"assistant","content":"WITH mobilite_analyse AS (SELECT p.id, SUM(e.amount) FILTER (WHERE e.description ILIKE '%transport%' OR e.description ILIKE '%déplacement%') as cout_deplacements, array_agg(DISTINCT jsonb_build_object('type_deplacement', CASE WHEN e.description ILIKE '%train%' THEN 'train' WHEN e.description ILIKE '%vehicule%' THEN 'vehicule' ELSE 'autre' END, 'distance', e.amount / CASE WHEN e.description ILIKE '%train%' THEN 0.15 WHEN e.description ILIKE '%vehicule%' THEN 0.45 ELSE 1 END)) as details_deplacements FROM projects p LEFT JOIN expenses e ON p.id = e.project_id WHERE e.description ILIKE ANY(ARRAY['%transport%', '%déplacement%', '%km%']) GROUP BY p.id) SELECT p.*, ma.*, jsonb_build_object('impact_carbone', CASE WHEN ma.cout_deplacements > 5000 THEN 'élevé' WHEN ma.cout_deplacements > 1000 THEN 'modéré' ELSE 'faible' END) as evaluation_mobilite FROM projects p LEFT JOIN mobilite_analyse ma ON p.id = ma.id WHERE p.status::project_status != 'annule' ORDER BY ma.cout_deplacements DESC;"}]}
{"messages":[{"role":"user","content":"Analyse des projets par cycle de vie"},{"role":"assistant","content":"WITH cycle_vie AS (SELECT p.id, s.stage_order, s.name as stage_name, s.duration_days as planned_duration, EXTRACT(DAY FROM (s.end_date - s.start_date)) as actual_duration, array_agg(DISTINCT jsonb_build_object('activite', al.action, 'date', al.created_at, 'impact', al.details->>'impact')) as activites FROM projects p JOIN stages s ON p.id = s.project_id LEFT JOIN activity_logs al ON s.id = al.entity_id AND al.entity_type = 'stage' GROUP BY p.id, s.stage_order, s.name, s.duration_days, s.start_date, s.end_date) SELECT p.*, cv.*, jsonb_build_object('performance_cycle', CASE WHEN cv.actual_duration <= cv.planned_duration THEN 'optimal' WHEN cv.actual_duration <= cv.planned_duration * 1.2 THEN 'acceptable' ELSE 'retard' END) as evaluation FROM projects p JOIN cycle_vie cv ON p.id = cv.id ORDER BY p.start_date, cv.stage_order;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de charge de travail par équipe"},{"role":"assistant","content":"WITH charge_equipe AS (SELECT p.id, s.team_id, t.name as team_name, COUNT(DISTINCT ps.staff_id) as effectif, SUM(te.hours) as heures_travaillees, array_agg(DISTINCT jsonb_build_object('role', s.role, 'charge', SUM(te.hours) OVER (PARTITION BY s.role))) as repartition_roles FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id JOIN teams t ON s.team_id = t.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id GROUP BY p.id, s.team_id, t.name) SELECT p.*, ce.*, jsonb_build_object('equilibre_charge', CASE WHEN ce.heures_travaillees / ce.effectif BETWEEN 30 AND 40 THEN 'equilibré' WHEN ce.heures_travaillees / ce.effectif > 40 THEN 'surcharge' ELSE 'sous-charge' END) as evaluation FROM projects p JOIN charge_equipe ce ON p.id = ce.id ORDER BY ce.heures_travaillees DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse budgétaire détaillée"},{"role":"assistant","content":"WITH budget_detail AS (SELECT p.id, SUM(e.amount) as depenses_totales, p.budget as budget_initial, array_agg(DISTINCT jsonb_build_object('categorie', e.category, 'montant', SUM(e.amount) OVER (PARTITION BY e.category), 'pourcentage', ROUND((SUM(e.amount) OVER (PARTITION BY e.category) / p.budget::float * 100), 2))) as repartition_depenses FROM projects p LEFT JOIN expenses e ON p.id = e.project_id GROUP BY p.id, p.budget) SELECT p.*, bd.*, jsonb_build_object('sante_financiere', CASE WHEN bd.depenses_totales <= bd.budget_initial * 0.9 THEN 'excellent' WHEN bd.depenses_totales <= bd.budget_initial THEN 'correct' ELSE 'depassement' END) as evaluation FROM projects p JOIN budget_detail bd ON p.id = bd.id ORDER BY bd.depenses_totales DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse de communication interne"},{"role":"assistant","content":"WITH comm_interne AS (SELECT p.id, COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'reunion') as nb_reunions, array_agg(DISTINCT jsonb_build_object('type_comm', al.action, 'frequence', COUNT(*) OVER (PARTITION BY al.action), 'participants', array_agg(DISTINCT s.firstname || ' ' || s.lastname))) as communications FROM projects p LEFT JOIN calendar_events ce ON p.id = ce.project_id LEFT JOIN activity_logs al ON p.id = al.entity_id AND al.entity_type = 'project' LEFT JOIN project_staff ps ON p.id = ps.project_id LEFT JOIN staff s ON ps.staff_id = s.id WHERE al.action::activity_type IN ('commentaire', 'notification', 'validation') GROUP BY p.id, al.action) SELECT p.*, ci.*, jsonb_build_object('qualite_communication', CASE WHEN ci.nb_reunions >= 4 THEN 'proactive' WHEN ci.nb_reunions > 0 THEN 'reguliere' ELSE 'insuffisante' END) as evaluation FROM projects p JOIN comm_interne ci ON p.id = ci.id ORDER BY ci.nb_reunions DESC;"}]}
{"messages":[{"role":"user","content":"Trouve les projets avec leur analyse de gestion documentaire"},{"role":"assistant","content":"WITH doc_analyse AS (SELECT p.id, COUNT(DISTINCT de.id) as total_documents, array_agg(DISTINCT jsonb_build_object('type', de.document_type, 'statut', de.status, 'versions', COUNT(*) OVER (PARTITION BY de.document_type))) as documents_details FROM projects p LEFT JOIN document_embeddings de ON p.id = de.document_id GROUP BY p.id) SELECT p.*, da.*, jsonb_build_object('maturite_documentaire', CASE WHEN da.total_documents > 15 THEN 'complete' WHEN da.total_documents > 5 THEN 'adequate' ELSE 'minimale' END) as evaluation FROM projects p JOIN doc_analyse da ON p.id = da.id ORDER BY da.total_documents DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de gestion des ressources matérielles"},{"role":"assistant","content":"WITH ressources_mat AS (SELECT p.id, COUNT(DISTINCT er.equipment_id) as equipements_utilises, array_agg(DISTINCT jsonb_build_object('equipement', e.name, 'duree_utilisation', SUM(EXTRACT(HOUR FROM (er.end_time - er.start_time))), 'cout', e.hourly_rate * SUM(EXTRACT(HOUR FROM (er.end_time - er.start_time))))) as utilisation_details FROM projects p LEFT JOIN equipment_reservations er ON p.id = er.project_id LEFT JOIN equipment e ON er.equipment_id = e.id GROUP BY p.id) SELECT p.*, rm.*, jsonb_build_object('optimisation_ressources', CASE WHEN rm.equipements_utilises > 5 THEN 'intensive' WHEN rm.equipements_utilises > 0 THEN 'normale' ELSE 'faible' END) as evaluation FROM projects p JOIN ressources_mat rm ON p.id = rm.id ORDER BY rm.equipements_utilises DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de conformité aux processus"},{"role":"assistant","content":"WITH conformite_process AS (SELECT p.id, COUNT(DISTINCT v.id) as validations_totales, array_agg(DISTINCT jsonb_build_object('processus', v.validation_type, 'statut', v.status, 'conformite', CASE WHEN v.status = 'valide' THEN true ELSE false END)) as validations_details FROM projects p LEFT JOIN validations v ON p.id = v.project_id GROUP BY p.id) SELECT p.*, cp.*, jsonb_build_object('niveau_conformite', CASE WHEN cp.validations_totales > 0 AND NOT EXISTS (SELECT 1 FROM jsonb_array_elements(cp.validations_details) j WHERE (j->>'conformite')::boolean = false) THEN 'conforme' WHEN cp.validations_totales > 0 THEN 'partiel' ELSE 'non_verifie' END) as evaluation FROM projects p JOIN conformite_process cp ON p.id = cp.id ORDER BY p.created_at DESC;"}]}
{"messages":[{"role":"user","content":"Montre les projets avec leur analyse de performance des intervenants"},{"role":"assistant","content":"WITH perf_intervenants AS (SELECT p.id, s.id as staff_id, s.firstname || ' ' || s.lastname as intervenant, COUNT(DISTINCT te.id) as interventions, SUM(te.hours) as heures_travaillees, array_agg(DISTINCT jsonb_build_object('tache', te.description, 'duree', te.hours, 'evaluation', CASE WHEN te.hours <= te.estimated_hours THEN 'efficace' ELSE 'depassement' END)) as details_interventions FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id LEFT JOIN timesheet_entries te ON p.id = te.project_id AND te.staff_id = s.id GROUP BY p.id, s.id, s.firstname, s.lastname) SELECT p.*, pi.*, jsonb_build_object('performance_globale', CASE WHEN pi.heures_travaillees > 0 AND pi.interventions / pi.heures_travaillees >= 0.8 THEN 'haute' WHEN pi.heures_travaillees > 0 THEN 'moyenne' ELSE 'indeterminee' END) as evaluation FROM projects p JOIN perf_intervenants pi ON p.id = pi.id ORDER BY pi.heures_travaillees DESC;"}]}
{"messages":[{"role":"user","content":"Liste les projets avec leur analyse de gestion des modifications"},{"role":"assistant","content":"WITH modif_analyse AS (SELECT p.id, COUNT(DISTINCT al.id) FILTER (WHERE al.action::activity_type = 'modification') as nb_modifications, array_agg(DISTINCT jsonb_build_object('type_modif', al.details->>'type', 'impact', al.details->>'impact', 'auteur', s.firstname || ' ' || s.lastname)) as details_modifications FROM projects p LEFT JOIN activity_logs al ON p.id = al.entity_id AND al.entity_type = 'project' LEFT JOIN staff s ON (al.details->>'author_id')::integer = s.id WHERE al.action::activity_type = 'modification' GROUP BY p.id) SELECT p.*, ma.*, jsonb_build_object('stabilite_projet', CASE WHEN ma.nb_modifications <= 3 THEN 'stable' WHEN ma.nb_modifications <= 10 THEN 'evolutif' ELSE 'instable' END) as evaluation FROM projects p JOIN modif_analyse ma ON p.id = ma.id ORDER BY ma.nb_modifications DESC;"}]}
{"messages":[{"role":"user","content":"Affiche les projets avec leur analyse de coordination inter-équipes"},{"role":"assistant","content":"WITH coord_equipes AS (SELECT p.id, COUNT(DISTINCT t.id) as nb_equipes_impliquees, array_agg(DISTINCT jsonb_build_object('equipe', t.name, 'interactions', COUNT(DISTINCT ce.id) FILTER (WHERE ce.event_type::event_type = 'reunion' AND ce.description ILIKE '%coordination%'), 'membres_impliques', array_agg(DISTINCT s.firstname || ' ' || s.lastname))) as interactions_equipes FROM projects p JOIN project_staff ps ON p.id = ps.project_id JOIN staff s ON ps.staff_id = s.id JOIN teams t ON s.team_id = t.id LEFT JOIN calendar_events ce ON p.id = ce.project_id GROUP BY p.id) SELECT p.*, ce.*, jsonb_build_object('niveau_coordination', CASE WHEN ce.nb_equipes_impliquees > 3 THEN 'complexe' WHEN ce.nb_equipes_impliquees > 1 THEN 'standard' ELSE 'simple' END) as evaluation FROM projects p JOIN coord_equipes ce ON p.id = ce.id ORDER BY ce.nb_equipes_impliquees DESC;"}]}
